<document>

{{'use client'

import { useState, useRef, ChangeEvent } from 'react'
import { SessionCheck } from '@/app/func/Sessioncheck'
import { UserIdCheck } from '@/app/func/Useridcheck'
import Link from 'next/link'
import { useRouter } from 'next/navigation'

import TitleInput from '@/app/components/Upload/TitleInput'
import DescriptionInput from '@/app/components/Upload/DescriptionInput'

import FileUploadButton from '@/app/components/Upload/FileUploadButton'
import SaveButton from '@/app/components/Upload/SaveButton'
import PreviewSection from '@/app/components/Upload/PreviewSection'
import { PostFormData, PostPart } from '../../../../../types'
import { handleSavePost } from '@/app/actions/handleSavePost/handleSavePost'
import PartsInput from '@/app/components/Upload/PartsInput'
import CategoryInput from '@/app/components/Upload/CategoryInput'

import { savePostAction } from '@/app/actions/savePost/savePost'

export default function UploadPage() {
	const router = useRouter()
	const status = SessionCheck()
	const userEmail = UserIdCheck()
	const [postData, setPostData] = useState<PostFormData>({
		title: '',
		description: '',
		parts: [{}],
		videourl: '',
		category: ''
		// tags: []
	})

	const [isLoading, setIsLoading] = useState(false)
	const [hasUploadedVideo, setHasUploadedVideo] = useState<boolean>(false)

	const handleFileChange = async (e: ChangeEvent<HTMLInputElement>) => {
		const file = e.target.files?.[0]
		if (file) {
			if (!file.type.startsWith('video/')) {
				alert('動画ファイルのみアップロードできます')
				return
			}

			const fileSizeInMB = file.size / (1024 * 1024)
			if (fileSizeInMB > 100) {
				alert('ファイルサイズが100MBを超えています。動画のファイルサイズが100MB以下の場合にアップロードできます')
				return
			}

			setIsLoading(true)

			try {
				const formData = new FormData()
				formData.append('file', file)

				const response = await fetch('/api/r2upload', {
					method: 'POST',
					body: formData
				})

				if (response.ok) {
					const data = await response.json()
					setPostData((prevPostData) => ({
						...prevPostData,
						videourl: data.url
					}))
					setHasUploadedVideo(true)
				} else {
					console.error('Error uploading file:', response.statusText)
				}
				setIsLoading(false)
			} catch (error) {
				console.error('Error uploading file:', error)
				setIsLoading(false)
			}
		}
	}

	const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
		e.preventDefault()

		try {
			if (!userEmail) {
				throw Error('User not found')
			}

			const postId = await handleSavePost(postData, userEmail)
			router.push(`/post/${postId}`)
		} catch (error) {
			console.error('Error saving post: ', error)
		}
	}

	if (status === 'authenticated') {
		return (
			<div className="bg-white text-black min-h-screen">
				<div className="container mx-auto px-4 py-8">
					<div className="bg-white">
						<h1 className="text-4xl font-bold mb-8">投稿を作成</h1>

						{/* TODO タイトルと動画を必須にする */}
						<form action={savePostAction}>
							<TitleInput
								title={postData.title}
								onTitleChange={(e) => setPostData({ ...postData, title: e.target.value })}
							/>

							<DescriptionInput
								description={postData.description}
								onDescriptionChange={(e) => setPostData({ ...postData, description: e.target.value })}
							/>

							<CategoryInput onCategoryChange={(category) => setPostData({ ...postData, category })} />

							<PartsInput
								parts={postData.parts}
								onPartsChange={(part) => {
									setPostData({ ...postData, parts: [part as PostPart] })
								}}
							/>

							{/* TODO ファイルアップロードはできてるけど、videourlが取得できていないところから */}
							{/* TODO 一度動画アップロードしたら、削除（取り消し）できるようにしたい */}
							<FileUploadButton
								onFileChange={handleFileChange}
								hasUploadedVideo={hasUploadedVideo}
								videoUrl={postData.videourl}
							/>

							<SaveButton type="submit" />
						</form>

						<PreviewSection videoUrl={postData.videourl} isLoading={isLoading} />
					</div>
				</div>
			</div>
		)
	} else if (!status || status === 'unauthenticated') {
		return (
			<div className="bg-white text-black min-h-screen">
				<div className="container mx-auto px-4 py-8">
					<p>
						<Link href={`/login`} className="text-black hover:text-gray-800">
							ログインしてください
						</Link>
					</p>
				</div>
			</div>
		)
	}

	return null
}
}}

{{export interface DefaultSession {
	user?: {
		name?: string | null
		email?: string | null
		image?: string | null
	}
	expires: ISODateString
}

export interface Post {
	id: string
	title: string
	description: string
	imageUrl?: string | null
	videoUrl?: string | null
	createdat: Date
	updatedat: Date
	user: {
		id: string
		name: string
		image?: string
	}
}

export interface PostsProps {
	posts: Post[]
	componentType: 'top' | 'profile' | null
	isCurrentUser: boolean
}

export interface PostFormData {
	title: string
	description: string
	videourl?: string
	parts: PostPart[]
	category: string
	// tags?: string[]
}

export interface PostPart {
	case?: string
	plate?: string
	switches?: string
	keyCaps?: string
}

export interface UpdateParts {
	id: string
	case: string
	plate: string
	switches: string
	keyCaps: string
	postId: string
}

export type PostEditFormData = Omit<Post, 'user'> & {
	user: { id: string }
	part: UpdateParts | null
	category: string
	// tags: UpdateTags[] | string[]
}

// export interface UpdateTags {
// 	tag: {
// 		id: string
// 		name: string
// 	}
// 	postId: string
// 	tagId: string
// }
}}

{{import React, { useState } from 'react'
import { PostPart, UpdateParts } from '../../../../types'

interface PartsInputProps {
	parts: PostPart[] | UpdateParts | null
	onPartsChange: (parts: PostPart | UpdateParts | null) => void
}

const PartsInput: React.FC<PartsInputProps> = ({ parts, onPartsChange }) => {
	const [partInput, setPartInput] = useState<PostPart>({
		case: Array.isArray(parts) ? parts[0]?.case ?? '' : parts?.case ?? '',
		plate: Array.isArray(parts) ? parts[0]?.plate ?? '' : parts?.plate ?? '',
		switches: Array.isArray(parts) ? parts[0]?.switches ?? '' : parts?.switches ?? '',
		keyCaps: Array.isArray(parts) ? parts[0]?.keyCaps ?? '' : parts?.keyCaps ?? ''
	})

	const handlePartChange = (field: keyof PostPart, value: string) => {
		setPartInput((prevPartInput) => ({
			...prevPartInput,
			[field]: value.trim() !== '' ? value : undefined
		}))
	}

	const handlePartBlur = () => {
		if (Array.isArray(parts)) {
			onPartsChange(partInput)
		} else {
			onPartsChange(partInput as UpdateParts)
		}
	}

	const handleRemovePart = (field: keyof PostPart) => {
		setPartInput((prevPartInput) => ({
			...prevPartInput,
			[field]: undefined
		}))
		onPartsChange({ ...partInput, [field]: undefined } as UpdateParts)
	}

	return (
		<div className="mb-8 pt-4">
			<h2 className="text-2xl font-semibold mb-2">パーツ</h2>
			<div>
				<input
					type="text"
					name="case"
					placeholder="ケース"
					className="w-full bg-gray-50 border border-gray-400 rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-gray-500 mb-2"
					value={partInput.case ?? ''}
					onChange={(e) => handlePartChange('case', e.target.value)}
					onBlur={handlePartBlur}
					onKeyDown={(e) => {
						if (e.key === 'Enter') {
							e.preventDefault()
						}
					}}
				/>
				<input
					type="text"
					name="plate"
					placeholder="プレート"
					className="w-full bg-gray-50 border border-gray-400 rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-gray-500 mb-2"
					value={partInput.plate ?? ''}
					onChange={(e) => handlePartChange('plate', e.target.value)}
					onBlur={handlePartBlur}
					onKeyDown={(e) => {
						if (e.key === 'Enter') {
							e.preventDefault()
						}
					}}
				/>
				<input
					type="text"
					name="switches"
					placeholder="スイッチ"
					className="w-full bg-gray-50 border border-gray-400 rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-gray-500 mb-2"
					value={partInput.switches ?? ''}
					onChange={(e) => handlePartChange('switches', e.target.value)}
					onBlur={handlePartBlur}
					onKeyDown={(e) => {
						if (e.key === 'Enter') {
							e.preventDefault()
						}
					}}
				/>
				<input
					type="text"
					name="keyCaps"
					placeholder="キーキャップ"
					className="w-full bg-gray-50 border border-gray-400 rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-gray-500 mb-2"
					value={partInput.keyCaps ?? ''}
					onChange={(e) => handlePartChange('keyCaps', e.target.value)}
					onBlur={handlePartBlur}
					onKeyDown={(e) => {
						if (e.key === 'Enter') {
							e.preventDefault()
						}
					}}
				/>
			</div>
			<div className="flex flex-col mt-4">
				{partInput.case && (
					<div className="bg-gray-200 rounded-md px-3 py-1 mr-2 mb-4 flex items-center font-bold text-lg">
						ケース: {partInput.case}
						<button
							type="button"
							className="ml-2 text-gray-600 hover:text-gray-800"
							onClick={() => handleRemovePart('case')}
						>
							×
						</button>
					</div>
				)}
				{partInput.plate && (
					<div className="bg-gray-200 rounded-md px-3 py-1 mr-2 mb-4 flex items-center font-bold text-lg">
						プレート: {partInput.plate}
						<button
							type="button"
							className="ml-2 text-gray-600 hover:text-gray-800"
							onClick={() => handleRemovePart('plate')}
						>
							×
						</button>
					</div>
				)}
				{partInput.switches && (
					<div className="bg-gray-200 rounded-md px-3 py-1 mr-2 mb-4 flex items-center font-bold text-lg">
						スイッチ: {partInput.switches}
						<button
							type="button"
							className="ml-2 text-gray-600 hover:text-gray-800"
							onClick={() => handleRemovePart('switches')}
						>
							×
						</button>
					</div>
				)}
				{partInput.keyCaps && (
					<div className="bg-gray-200 rounded-md px-3 py-1 mr-2 mb-4 flex items-center font-bold text-lg">
						キーキャップ: {partInput.keyCaps}
						<button
							type="button"
							className="ml-2 text-gray-600 hover:text-gray-800"
							onClick={() => handleRemovePart('keyCaps')}
						>
							×
						</button>
					</div>
				)}
			</div>
		</div>
	)
}

export default PartsInput
}}

{{'use server'

import { getServerSession } from 'next-auth/next'
import { PostFormData } from '../../../../types'
import { handleSavePost } from '../handleSavePost/handleSavePost'
import { authOptions } from '@/auth/[...nextauth]'
import { redirect } from 'next/navigation'

export const savePostAction = async (formData: FormData) => {
	console.log('savePostAction formdata', formData)

	// TODO パーツは取得できているけど、nullになるのはなぜか
	// test console -> parts: [ { case: null, plate: null, switches: null, keyCaps: null } ]
	const title = formData.get('title') as string
	const description = formData.get('description') as string
	const videourl = formData.get('videourl') as string
	const category = formData.get('category') as string
	const partCase = formData.get('partCase') as string
	const partPlate = formData.get('partPlate') as string
	const partSwitches = formData.get('partSwitches') as string
	const partKeyCaps = formData.get('partKeyCaps') as string

	const postData: PostFormData = {
		title,
		description,
		videourl,
		category,
		parts: [{ case: partCase, plate: partPlate, switches: partSwitches, keyCaps: partKeyCaps }]
	}

	console.log('savePostAction', postData)

	let postId
	try {
		const session = await getServerSession(authOptions)
		if (!session?.user?.email) {
			throw Error('User not found')
		}

		postId = await handleSavePost(postData, session?.user.email)
		// return { postId }
	} catch (error) {
		console.error('Error saving post: ', error)
		throw error
	}

	redirect(`/post/${postId}`)
}
}}

{{generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id        String    @id @default(uuid())
  name      String
  email     String    @unique
  image     String
  createdat DateTime  @default(now())
  updatedat DateTime  @updatedAt
  profile   Profile?
  posts     Post[]
  likes     Like[]
  comments  Comment[]
}

model Profile {
  id         String  @id @default(uuid())
  bio        String?
  screenName String? @unique
  userId     String  @unique
  user       User    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Post {
  id          String    @id @default(cuid())
  userId      String
  title       String
  description String
  imageUrl    String?
  videoUrl    String?
  createdat   DateTime  @default(now())
  updatedat   DateTime  @updatedAt
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  likes       Like[]
  comments    Comment[]
  part        Part?
  category    Category? @relation(fields: [categoryId], references: [id])
  categoryId  String?
}

model Part {
  id       String @id @default(cuid())
  case     String
  plate    String
  switches String
  keyCaps  String
  post     Post   @relation(fields: [postId], references: [id])
  postId   String @unique
}

model Category {
  id    String @id @default(cuid())
  name  String @unique
  posts Post[]
}

model Like {
  id        String   @id @default(cuid())
  userId    String
  postId    String
  createdat DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
}

model Comment {
  id        String   @id @default(cuid())
  userId    String
  postId    String
  body      String
  createdat DateTime @default(now())
  updatedat DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
}
}}

</document>

あなたはNext.js・フロントエンドエンジニアの天才です。
コードを分析してほしい。

現在の問題は、formDataからpartは取得できているが、prisma経由でparts情報が保存されないことです。

	// TODO パーツは取得できているけど、nullになるのはなぜか
	// test console -> parts: [ { case: null, plate: null, switches: null, keyCaps: null } ]

ステップバイステップで考えてください。気合い入れて、深呼吸して、批判的でありながら、整合性を保って、一歩ずつ課題に取り組んでください

